# 스위프트 프로그래밍(Swift 5)
> 야곰님의 스위프트 프로그래밍 3판 책을 참고하여 작성하였습니다.

## 목차
- [3. 데이터 타입 기본](#3)
- [4. 데이터 타입 고급](#4)
- [5. 연산자](#5)
- [6. 흐름 제어](#6)
- [7. 함수](#7)
- [8. 옵셔널](#8)

# 데이터 타입 기본 <a id="3"></a>
## Int와 Unit
- **Int는 +, - 부호를 포함한 정수, Unit는 - 부호를 포함하지 않는 0을 포함한 양의 정수**
- 8비트, 16비트, 32비트, 64비트의 형태가 존재.

## Bool
- **true 또는 false의 값을 가짐.**

## Float와 Double
- 64비트의 부동소수 표현하는 Double(15자리), 32비트의 부동소수 표현하는 Float(6자리)

## Character
- 단어, 문장처럼 문자의 집합이 아닌 단 하나의 문자를 의미.

## String
- 문자의 나열, 즉 문자열을 의미.
- append() 메서드 또는 +를 사용하여 문자열을 이어붙일 수 있음
- count 프로퍼티를 통해 문자의 수를 셀 수 있음
- isEmpty 프로퍼티를 통해 빈 문자열인지 확인 가능
- 이외에도 hasPrefix, hasSuffix, uppercased, lowercased 등이 존재

### 특수문자
|특수문자|설명|
| --- | --- |
| \n | 줄바꿈 문자 |
| \\ | 문자열 내에서 백슬래시를 표현하고자 할 때 사용 |
| \" | 문자열 내에서 큰따옴표를 표현하고자 할 때 사용 |
| \t | 탭 문자. 키보드의 탭키를 눌렀을 때와 같은 효과 |
| \0 | 문자열이 끝났음을 알리는 null 문자 |

## Any, AnyObject와 nil
- Any : 모든 데이터 타입을 사용할 수 있다는 뜻
- AnyObject : 클래스의 인스턴스만 할당 가능.
- nil : '없음'을 나타내는 키워드, 값이 비어있음을 나타낼 때 사용.

# 데이터 타입 고급 <a id="4"></a>
> 스위프트는 타입에 굉장히 민감하고 엄격하다. 서로 다른 타입끼리의 교환은 꼭 타입캐스팅을 거쳐야 한다.

### 타입 추론
- 변수나 상수를 선언할 때 특정 타입을 명시하지 않아도 컴파일러가 할당된 값을 기준으로 변수나 상수의 타입을 결정.

## 타입 별칭
- 데이터 타입에 임의로 다른 이름을 부여할 수 있다.
````swift
typealias MyInt = Int // Int의 이름이 MyInt가 된 것이다.
````

## 튜플
- 타입의 이름이 따로 **지정되어 있지 않은, 프로그래머 마음대로 만드는 타입**
- 파이썬의 튜플과 매우 유사
````swift
var person: (String, Int, Double) = ("yagom", 100, 182.5)

var person: (name: String, age: Int, height: Double) = ("yagom", 100, 182.5)
// 이렇게하면 인덱스를 수가 아닌 변수로 가능. 타입 별칭으로 더 편하게 만들 수도 있다.

// 인덱스 가능
print("이름: \(person.0), 나이: \(person.1), 신장: \(person.2)")

person.1 = 99 // 할당도 가능
````

## 컬렉션형
### 배열
- **같은 타입의 데이터**를 일렬로 나열한 후, 순서대로 저장하는 형태의 컬렉션 타입.
````swift
// 대괄호를 사용해 배열임을 표현
var names: Array<String> = ["yagom", "chulsoo", "younghee", "gracekim"]

// 이렇게도 표현 가능.
var names: [String] = ["yagom", "chulsoo", "younghee", "gracekim"]

var emptyArray: [Any] = []  // 배열의 타입이 정확하다면 빈 배열도 생성 가능.
````

- append() 메서드를 통해 마지막에 요소 추가 가능.
- insert(변수, at: 인덱스번호) 메서드를 통해 인덱스번호에 변수 요소 추가 가능.
- contentsOf로 배열의 형태로 묶을 수 있음.
- firstIndex(of: ) 메서드를 통해 해당 요소의 인덱스를 알아낼 수 있음.
- first, last를 이용해 처음과 마지막의 요소를 알 수 있음.
- removeFirst(), removeLast(), remove(at: 인덱스번호)를 통해 제거가능.
- indexZeroItem 프로퍼티를 통해 0인 인덱스요소를 알 수 있음.

### 딕셔너리
- 요소들의 **순서없이** 키와 값의 쌍으로 구성되는 컬렉션 타입.
- 딕셔너리 안에는 키가 하나이거나 여러 개일 수는 있으나, 하나의 딕셔너리 안의 키는 같은 이름을 중복해서 사용할 수 없음.
````swift
var numberForName: Dictionary<String, Int> = Dictionary<String, Int>()

var numberForName: [String, Int] = [String: Int]()

// 타입 명시가 확실하게 되어있다면 빈 딕셔너리도 생성 가능.
var numberForName: [String, Int] = [:]

````

- 배열과는 다르게 없는 키로 접근을 해도 오류가 발생하지 않으나, nil을 반환함.

### 세트
- 같은 타입의 데이터를 순서 없이 하나의 묶음으로 저장하는 형태의 컬렉션 타입.
- 모두 유일한 값이고, 중복된 값이 존재하지 않음. 
- **순서가 중요하지 않거나 각 요소가 유일한 값이어야 하는 경우 사용**

````swift
var names: Set<String> = Set<String>()
var names: Set<String> = [] // 빈 세트 생성

var names: Set<String> = ["yagom", "gracekim", "younghee"]

print(names.isEmpty) // false
print(names.count) // 3 - 중복된 값x
````

- 집합연산이 가능. 
- intersection - 교집합
- symmetricDifference - 여집합의 합(배타적 논리합)
- union - 합집합
- subtracting - 차집합

## 열거형
- 열거형은 배열이나 딕셔너리와 다르게 프로그래머가 정의해준 항목 값 외에는 추가/수정이 불가.

### 기본 열거형
- 열거형 선언 방법
````swift
enum School {
    case primary
    case elementary
    case middle
    case high
    case college
    case university
    case graduate
}

enum School {
    case primary, elementary, middle, high, college, university, graduate
}

var highestEducationLevel: School = School.university
````

### 원시 값
- 특정 타입으로 지정된 값을 가질 수 있음.

````swift
enum School {
    case primary, elementary, middle, high, college, university, graduate
}

let highestEducationLevel: Schoool = School.university
print("저의 최종학력은 \(highestEducationLevel.rawValue) 졸업입니다.")
// 대학교
````

### 연관 값
- 열거형 내의 항목이 자신과 연관된 값을 가질 수 있음. 연관 값은 각 항목 옆에 소괄호로묶어 표현할 수 있음.
````swift
enum MainDish {
    case pasta(taste: String)
    case pizza(dough: String, topping: String)
    case chicken(withSauce: true)
    case rice
}

var dinner: MainDish = MainDish.pasta(taste: "크림")
dinner = .pizza(dough: "치즈크러스트", topping: "불고기")
````

### 항목 순회
- allCases를 통해 모든 케이스를 확인 가능.
````swift
enum School: CaseIterable {
    case primary = "유치원"
    case elementary = "초등학교"
    case middle = "중학교"
    case high = "고등학교"
    case college = "대학"
    case university = "대학교"
    case graduate = "대학원"
}

let allCases: [School] = School.allCases
print(allCases)
````

### 순환 열거형 
- 열거형 항목의 연관 값이 열거형 자신의 값이고자 할 때 사용. 순환 열거형을 명시하고자 한다면 indirect 키워드를 사용.

# 연산자 <a id="5"></a>
## 연산자의 종류
### 할당 연산자
- 값을 할당 

연산자 | 부호 | 설 명
--- | ---- | ----
할당연산자 | A = B | A에 B에 값을 할당

### 산술 연산자 
- 수학에서 쓰이는 연산자와 같은 역할

### 비교 연산자 
- 두 값을 비교할 때 사용
- == , >=, =<, <, >, !=, ===(A와 B가 참조타입일 때, A와 B가 같은 인스턴스를 가리키는지 비교하는 것), !==, ~=(A와 B의 패턴이 매치되는지 확인)

### 삼항 조건 연산자
- 피연산자가 세 개인 삼항 조건 연산자

연산자 | 부호 | 설 명
--- | ---- | ----
삼항조건연산자 | Question ? A : B | Quesion(불리언 값)이 참이면 A, 거짓이면 B를 반환

````swift
var valueA: Int = 3
var valueB: Int = 5
var biggerValue: Int = valueA > valueB ? valueA : valueB
````

### 범위 연산자
연산자 | 부호 | 설 명
--- | ---- | ----
폐쇄 범위 연산자 | A...B | A부터 B까지의 수를 묶어 범위를 표현. A와 B를 포함
반폐쇄 범위 연산자 | A.. < B | A부터 B 미만까지의 수를 묶어 범위를 표현.
단방향 범위 연산자 | A... | A 이상의 수를 묶어 범위 표현

### 부울 연산자
연산자 | 부호 | 설 명
--- | ---- | ----
NOT 부울 연산자 | !B| B의 참, 거짓을 반전
AND 부울 연산자 | A && B | A와 B의 불리언 AND 논리 연산을 실행
OR 부울 연산자 | A || B | A와 B의 불리언 OR 논리 연산 실행

### 비트 연산자
- ~A, A & B, A | B, A ^ B | A >> B | A << B

### 복합 할당 연산자
- +=, -=. *=, /=, %=, <<=, >>=, &=, |=, ^=

### 오버플로 연산자
- 오버플로에 대비한 연산자
- &+, &-, &*

### 기타 연산자
- A ?? B, -A, O! V?

# 흐름 제어 <a id="6"></a>
## 조건문
### if 구문
if, else 등의 키워드 사용하고, **if 구문의 조건의 값이 꼭 Bool 값이어야 함.**
- 소괄호 ()의 사용은 자유다.

### switch 구문
- switch 구문의 case를 연속 실행하려면 fallthrough 키워드 사용
- 각 case에 들어가는 비교 값은 입력 값과 데이터 타입의 값이 같아야 함.
- 명확히 한정적인 값(열거형 값 등)이 아닐 때는 default를 사용해야 함.

````swift
let integerValue: Int = 5

switch integerValue {
case 0:
    print("value == zero")
case 1...10:
    print("value == 1~10")
case Int.min..<0, 101..<Int.max:
    print("value <0 or value> 100")
    break
default:
    print("10 < Value <= 100")
}

````

- switch에서 와일드카드(_)를 사용하면 좀 더 유용하다.
````swift
typealias NameAge = (name: String, age: Int)

let tupleValue: NameAge = ("yagom", 99)

switch tupleValue {
case ("yagom", 99):
    print("정확히 맞췄습니다.")
case (_, 99):
    print("나이만 맞았습니다.")
case ("yagom", _):
    print("이름만 맞았습니다.")
default:
    print("누굴 찾나요")
}

````

## 반복문
### for-in 구문
````swift
for 임시상수 in 시퀸스 아이템 {
    실행코드
}
````

````swift
for i in 0...5 {
    if i.isMultiple(of: 2){
        print(i)
        continue
    }

    print("\(i) == 홀수")
}
````

### while 구문
````swift
var names: [String] = ["gracekim", "asdf"]

while names.isEmpty == false {
    print("Good bye \(names.removeFirst())")
    // removeFirst()는 요소 삭제함과 동시에 삭제한 요소를 반환
}

````

### repeat-while 구문
- repeat 블록의 코드를 최초 1회 실행한 후, while 다음의 조건이 성립하면 블록 내부의 코드를 반복 실행.

## 구문 이름표
- 반복문 앞에 구문의 이름을 지정해줄 수 있음.
````swift
var numbers: [Int] = [3, 2342, 6, 3252]

numbersLoop: for num in numbers {
    if num > 5 || num < 1 {
        continue numbersLoop
    }
    
    var count: Int = 0
    
    printLoop: while true {
        print(num)
        count += 1
        
        if count == num {
            break printLoop
        }
    }
    
    removeLoop: while true {
        if numbers.first != num {
            break numbersLoop
        }
        numbers.removeFirst()
    }
}

````

# 함수 <a id="7"></a>
## 함수와 메서드
- 메서드 : 구조체, 클래스, 열거형 등 특정 타입에 연관되어 사용하는 함수
- 함수 : 모듈 전체에서 전역적으로 사용할 수 있는 함수

## 함수의 정의와 호출
- 재정의(오버라이드)와 중복 정의(오버로드)를 모두 지원.
- **매개변수의 타입이 다르면 같은 이름의 함수를 여러 개 만들 수 있음.**

### 기본적인 함수의 정의와 호출
- 기본적인 형태
```swift
func hello(name: String) -> String {
    return "Hello \(name)!"
}

let Hello: String = hello(name: "gracekim")
print(Hello)
```

- 함수 내부의 코드가 한 줄의 표현이고, 그 표현의 결괏값의 타입이 함수의 반환 타입과 일치하다면 return 키워드를 생략해도 그 표현의 결괏값이 함수의 반환값이 됨.

### 매개변수
#### 매개변수가 있는 함수와 없는 함수

- 매개변수가 있는 함수
```swift 

func sayHello(myName: String, yourName: String) -> String {
    return "Hello \(yourName)! I'm \(myName)"
}

print(sayHello(myName: "gracekim", yourName: "Jenny"))

```

- 매개변수 이름과 전달인자 레이블 

```swift

func sayHello(from myName: String, to name:String) -> String {
    return "Hello \(name)! I'm \(myName)"
}

print(sayHello(from: "gracekim", to: "Jenny"))

```

전달인자 레이블을 지정하면 함수 외부에서 매개변수의 역할을 좀 더 명확히 할 수 있음.

- 전달인자 레이블이 없는 함수 정의와 사용
```swift
func sayHello(_ name: String, _ times: Int) -> String {
    var result: String = ""
    
    for _ in 0..<times {
        result += "Hello \(name)!" + " "
    }
    
    return result
}

print(sayHello("Gracekim", 2))

```
또한, 전달인자 레이블을 변경하면 함수의 이름 자체가 변경.

#### 매개변수 기본값
- 매개변수가 전달되지 않으면 기본값을 사용하도록 지정할 수 있음.

```swift
func sayHello(_ name: String, times: Int = 3) -> String {
    var result: String = ""
    
    for _ in 0..<times {
        result += "Hello \(name)!" + " "
    }
    
    return result
}

print(sayHello("Hana"))

```

### 가변 매개변수와 입출력 매개변수 
- 가변 매개변수로 돌아온 인자 값은 배열처럼 사용가능.
```swift
func sayHelloToFriends(me: String, friends names: String...) -> String {
    var result: String = ""
    
    for friend in names {
        result += "Hello \(friend)!" + " "
    }
    
    result += "I'm " + me + "! "
    return result
}

print(sayHelloToFriends(me: "gracekim", friends: "heemin", "jisung", "donghu"))

```

- 함수의 전달인자로 값을 전달할 때는 **값을 복사해서 전달**함. **참조**를 전달하기 위해서는 입출력 매개변수를 사용.

### 반환이 없는 함수
- 반환이 필요하지 않을 때는 반환 타입이 Void이거나, 반환 값이 아예 없는 함수.

```swift
func sayHelloWorld() {
    // ... 
}
```

- (Void) -> Void
- () -> () 
으로 표현가능


### 데이터 타입으로서의 함수
```swift
func sayHello(name: String, times: Int) -> String {
    // ...
}
```

## 종료되지 않는 함수
- 정상적으로 끝나지 않는 함수라는 뜻. 비반환 함수는 정상적으로 끝날 수 없는 함수.
- 비반환 함수는 어디서든 호출이 가능하고 guard 구문의 else 블록에서도 호출 가능.
- 반환 타입을 Never라고 명시 

```swift
func crashAndBurn() -> Never {
    fatalError("very bad")
}

crashAndBurn() // 프로세스 종료 후 오류 보고
```

## 반환 값을 무시할 수 있는 함수
- 가끔 함수의 반환이 필요하지 않는 경우에 사용함. @discardableResult을 사용하면 됨.

```swift
func say(_ somthing: String) -> String {
    print(something)
    return something
}

@discardableResult func discadableResultSay(_ something: String) -> String {
    print(something)
    return something
}

// 반환 값을 사용하지 않았으므로 컴파일러가 경고를 표시
say("hello")

// 반환 값을 사용하지 않을 수 있다고 미리 알렸기 때문에 경고x
discadableResultSay("Hello")
```

# 옵셔널 <a id="8"></a>
## 옵셔널 사용
- 옵셔널을 읽을 때 '해당 변수 또는 상수에는 값이 없을 수 있다. 즉, 변수 또는 상수가 nil일 수도 있으므로 사용에 주의하라'는 뜻

```swift
var myName: String = "gracekim"
myName = nil
```

- 옵셔널 변수 또는 상수 등은 데이터 타입 뒤에 물음표(?)를 붙여 표현

## 옵셔널 추출
### 강제 추출
- 가장 간단하지만 가장 위험한 방법. 옵셔널 값 뒤에 느낌표(!)를 붙여주면 값을 강제로 추출 가능. 그러나 옵셔널에 값이 없다면, 즉 nid이라면 런타임 오류가 발생 

```swift
var myName: String? = "gracekim"
var gracekim: String = myName!

myName = nil
gracekim = myName!

if myName != nil {
    print("My name is \(myName)")
} else {
    print("myName == nil")
}
```

### 옵셔널 바인딩
- 옵셔널에 값이 있는지 확인할 때 사용. 옵셔널 값이 있다면 옵셔널에서 추출한 값을 일정 블록 안에서 사용할 수 있는 상수나 변수로 할당해서 옵셔널이 아닌 형태로 사용할 수 있도록 해줌. 

```swift

// 옵셔널 바인딩을 통한 임시 상수 할당
var myName: String? = "gracekim"

if let name = myName {
    print("My name is \(name)")
} else {
    print("myName == nil")
}

// 옵셔널 바인딩을 통한 임시 변수 할당
if var name = myName {
    name = "wizplan" // 변수이므로 내부에서 할당가능
    print("My name is \(name)")
} else {
    print("myName == nil")
}

var yourName: String? = nil
if let name = myName, let friend = yourName {
    print("We are friend! \(name) & \(friend)")
} 
// friend에 바인딩 되지 않아 실행 x
```

### 암시적 추출 옵셔널